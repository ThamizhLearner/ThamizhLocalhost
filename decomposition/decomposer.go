package decomposition

import (
	"fmt"
	"slices"
	"strings"

	script "github.com/ThamizhLearner/Thamizh"
)

/*
	[x] Trimmer interface provider implementations
	[x] Decomposition infrastructure & mechanism

	ASSUMPTION: Given word is valid. [Finding correct decomposition itself is the end goal]

	Word = frag1 + suff1
	frag1 = frag2 + suff2
	frag2 = frag3 + suff3

	Word
	Word = (frag1 + suff1)
	Word = ((frag2 + suff2) + suff1)
	Word = (((frag3 + suff3) + suff2) + suff1)
	NOTE: All this is fine, iff frag3 could be proven to be acceptable! [Frag3 could not be further split by the existing set of suffixTrimmers]

	Single decomposition chain v/s multiple decomposition chains [For the same word]
	Multiplicity occurs due to following reasons:
		Multiple (possible) suffix trimmers apply
		Multiple (possible) remnants are generated by suffix trimmers
*/

/*
	Syntax Decomposition API

	SyntaxDecomposer interface
		Decompose () []Decomposition

	Decomposition interface [Returns strings to keep the client simple, to start with]
		Final/composite form (string)
		Stages ([]string) [REQ: Cause it does not yet know when to stop!]

	Syntax Decomposition Interaction API [Abstract DOM => HTML DOM]
		View model implementation

*/

// Recursive trimming, applied to the remnant from the previous trim
type Decomposition struct { // Fine for single chain!
	mainStr string // String being decomposed

	// Ordered trim operations
	// Last trim holds the final remnant (which could not be trimmed further)
	suffixes []Remnant
}

type Remnant struct { // Note: Source str is not retained (here)!
	str     script.String // Actual remnant string
	trimmer SuffixTrimmer // Suffix trimmer (which helped generate the remnant string)
}

// Simply generates all possible decompositons
func Decompose(str script.String) []Decomposition {
	var growingDecomp []Decomposition // Decomposition chains
	// First let's create some seed decompositions!
	for _, r := range GetRemnants(str) {
		growingDecomp = append(growingDecomp, Decomposition{mainStr: str.String(), suffixes: []Remnant{r}})
	}
	// Note: Decomposition chain may grow/split/stop
	// When all chains stop growing, we're done!
	for {
		var branchedDecomps []Decomposition
		gotGrowth := false
		for decompIdx := range growingDecomp {
			decomp := &growingDecomp[decompIdx] // Decomposition struct needs to mutate! (to update suffixes list)
			nstr := decomp.suffixes[len(decomp.suffixes)-1].str
			remnants := GetRemnants(nstr)
			if len(remnants) == 0 { // Not "growing" ...
				continue
			}
			gotGrowth = true
			for rIdx, r := range remnants {
				if rIdx == 0 { // Growing...
					decomp.suffixes = append(decomp.suffixes, r)
					continue
				}
				// Branched... [Additional decompositions have appeared...]
				// Clone the decomposition before growing it further
				count := len(decomp.suffixes)
				branched := Decomposition{ // Clone the Decomposition
					mainStr:  decomp.mainStr,
					suffixes: slices.Clone(decomp.suffixes[:count-1]), // Skip the last one! [While cloning...]
				}
				branched.suffixes = append(branched.suffixes, r)
				branchedDecomps = append(branchedDecomps, branched)
			}
		}
		if len(branchedDecomps) != 0 {
			growingDecomp = append(growingDecomp, branchedDecomps...)
		}
		if !gotGrowth {
			break
		}
	}
	return growingDecomp
}

// Simply generates all possible Remnants
func GetRemnants(str script.String) []Remnant {
	var remnants []Remnant
	for _, trimmer := range Trimmers {
		for _, remnantStr := range trimmer.Trim(str) {
			len := remnantStr.Len()
			if len == 0 { // No remnant, skip!
				break
			}
			if len == 1 && remnantStr.FirstLetter().IsC() { // Remnant is a Consonant, ignore!
				break
			}
			if len >= 2 && remnantStr.LastLetter().IsC() && remnantStr.LetterAt(len-2).IsC() {
				break
			}
			remnants = append(remnants, Remnant{str: remnantStr, trimmer: trimmer})
		}
	}
	return remnants
}

func DecomposeWord(wd string) [][]string {
	str, ok := script.Decode(wd)
	if !ok {
		return nil
	}
	decomps := Decompose(str)
	if len(decomps) == 0 {
		return [][]string{{wd}}
	}
	var decompositions [][]string
	sb := strings.Builder{}
	for _, decomp := range decomps {
		var stageStrs []string
		for count := 1; count <= len(decomp.suffixes); count++ {
			// Reverse the suffixes!
			suffixes := slices.Clone(decomp.suffixes[:count])
			slices.Reverse(suffixes)
			sb.Reset()
			for _, sfx := range suffixes {
				if sb.Len() == 0 {
					sb.WriteString(sfx.str.String())
				}
				sb.WriteString("-")
				sb.WriteString(sfx.trimmer.GetSuffix().String())
			}
			stageStrs = append(stageStrs, sb.String()) // Snapshoot the decomposition as it stands now!
		}
		decompositions = append(decompositions, stageStrs)
	}
	return decompositions
}

func TestDecomposition() {
	for _, listStrs := range DecomposeWord("மரங்கள்") {
		fmt.Println("Dump")
		for _, str := range listStrs {
			fmt.Println("  ", str)
		}
	}
}
