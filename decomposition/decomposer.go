package decomposition

import (
	"fmt"
	"slices"
	"strings"

	script "github.com/ThamizhLearner/Thamizh"
)

/*
	[x] Trimmer interface provider implementations
	[x] Decomposition infrastructure & mechanism

	ASSUMPTION: Given word is valid. [Finding correct decomposition itself is the end goal]

	Word = frag1 + suff1
	frag1 = frag2 + suff2
	frag2 = frag3 + suff3

	Word
	Word = (frag1 + suff1)
	Word = ((frag2 + suff2) + suff1)
	Word = (((frag3 + suff3) + suff2) + suff1)
	NOTE: All this is fine, iff frag3 could be proven to be acceptable! [Frag3 could not be further split by the existing set of suffixTrimmers]

	Single decomposition chain v/s multiple decomposition chains [For the same word]
	Multiplicity occurs due to following reasons:
		Multiple (possible) suffix trimmers apply
		Multiple (possible) remnants are generated by suffix trimmers
*/

// Recursive trimming, applied to the remnant from the previous trim
type Decomposition struct { // Fine for single chain!
	mainStr string // String being decomposed

	// Ordered trim operations
	// Last trim holds the final remnant (which could not be trimmed further)
	suffixes []Remnant
}

type Remnant struct { // Note: Source str is not retained (here)!
	str     script.String // Actual remnant string
	trimmer SuffixTrimmer // Suffix trimmer (which helped generate the remnant string)
}

// Simply generates all possible decompositons
func Decompose(str script.String) []Decomposition {
	var growingDecomp []Decomposition // Decomposition chains
	// First let's create some seed decompositions!
	for _, r := range GetRemnants(str) {
		growingDecomp = append(growingDecomp, Decomposition{mainStr: str.String(), suffixes: []Remnant{r}})
	}
	// Note: Decomposition chain may grow/split/stop
	// When all chains stop growing, we're done!
	for {
		var branchedDecomps []Decomposition
		gotGrowth := false
		for decompIdx := range growingDecomp {
			decomp := &growingDecomp[decompIdx] // Using pointer!!!
			nstr := decomp.suffixes[len(decomp.suffixes)-1].str
			remnants := GetRemnants(nstr)
			if len(remnants) == 0 { // Not "growing" ...
				continue
			}
			gotGrowth = true
			for rIdx, r := range remnants {
				if rIdx == 0 { // Growing...
					decomp.suffixes = append(decomp.suffixes, r)
					continue
				}
				// Branched... [Additional decompositions have appeared...]
				// Clone the decomposition before growing it further
				count := len(decomp.suffixes)
				branched := Decomposition{
					mainStr:  decomp.mainStr,
					suffixes: slices.Clone(decomp.suffixes[:count-1]), // Skip the last one! [While cloning...]
				}
				branched.suffixes = append(branched.suffixes, r)
				branchedDecomps = append(branchedDecomps, branched)
			}
		}
		if len(branchedDecomps) != 0 {
			growingDecomp = append(growingDecomp, branchedDecomps...)
		}
		if !gotGrowth {
			break
		}
	}
	return growingDecomp
}

// Simply generates all possible Remnants
func GetRemnants(str script.String) []Remnant {
	var remnants []Remnant
	for _, trimmer := range Trimmers {
		for _, remnantStr := range trimmer.Trim(str) {
			remnants = append(remnants, Remnant{str: remnantStr, trimmer: trimmer})
		}
	}
	return remnants
}

func DecomposeWord(wd string) []string {
	if len(Trimmers) == 0 {
		Trimmers = append(Trimmers, NewSingularizationDef())
	}

	str, ok := script.Decode(wd)
	if !ok {
		return nil
	}
	decomps := Decompose(str)
	if len(decomps) == 0 {
		return []string{wd}
	}
	sb := strings.Builder{}
	var strs []string
	for _, decomp := range decomps {
		sb.Reset()
		suffixes := slices.Clone(decomp.suffixes)
		slices.Reverse(suffixes)
		for _, sfx := range suffixes {
			if sb.Len() == 0 {
				sb.WriteString(sfx.str.String())
			}
			sb.WriteString("-")
			sb.WriteString(sfx.trimmer.GetSuffix())
		}
		strs = append(strs, sb.String())
	}
	return strs
}

func TestDecomposition() {
	for _, str := range DecomposeWord("மரங்கள்") {
		fmt.Println(str)
	}
}
